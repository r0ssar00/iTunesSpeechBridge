
//******************************************************************************
// RCF - Remote Call Framework
// Copyright (c) 2005 - 2009, Jarl Lindrud. All rights reserved.
// Consult your license for conditions of use.
// Version: 1.1
// Contact: jarl.lindrud <at> gmail.com 
//******************************************************************************

#include <RCF/TcpAsioServerTransport.hpp>

#include <RCF/Asio.hpp>
#include <RCF/TcpClientTransport.hpp>
#include <RCF/TcpEndpoint.hpp>

namespace RCF {

    class TcpAsioAcceptor : public AsioAcceptor
    {
    public:
        TcpAsioAcceptor(AsioDemuxer & demuxer) : 
            mAcceptor(demuxer)
        {}

        void open(const std::string & networkInterface, int portIn, int & portOut)
        {
            boost::asio::ip::tcp::endpoint endpoint(
                boost::asio::ip::address::from_string(networkInterface),
                static_cast<unsigned short>(portIn));

            mAcceptor.open(endpoint.protocol());
            mAcceptor.set_option(boost::asio::socket_base::reuse_address(true));
            mAcceptor.bind(endpoint);
            mAcceptor.listen();

            // retrieve the port number, if it's generated by the system
            int fd = mAcceptor.native();
            portOut = portIn;
            if (portIn == 0 && (portOut = getFdPort(fd)) == 0)
            {
                int err = Platform::OS::BsdSockets::GetLastError();
                RCF_THROW(Exception(
                    RcfError_Socket, err, RcfSubsystem_Os, "getsockname() failed"))
                    (fd)(portIn)(networkInterface);
            }
        }

        boost::asio::ip::tcp::acceptor mAcceptor;
    };

    typedef boost::asio::ip::tcp::socket        TcpAsioSocket;
    typedef boost::shared_ptr<TcpAsioSocket>    TcpAsioSocketPtr;

    // TcpAsioSessionState

    class TcpAsioSessionState : public AsioSessionState
    {
    public:
        TcpAsioSessionState(
            TcpAsioServerTransport &transport,
            AsioDemuxerPtr demuxerPtr) :
                AsioSessionState(transport, demuxerPtr),
                mSocketPtr(new TcpAsioSocket(*demuxerPtr))
        {}

        const I_RemoteAddress & implGetRemoteAddress()
        {
            return mIpAddress;
        }

        void implRead(char * buffer, std::size_t bufferLen)
        {
            mSocketPtr->async_receive(
                boost::asio::buffer( buffer, bufferLen),
                0,
                boost::bind(
                    &AsioSessionState::onReadCompletion,
                    shared_from_this(),
                    boost::asio::placeholders::error,
                    boost::asio::placeholders::bytes_transferred));
        }

        void implWrite(const char * buffer, std::size_t bufferLen)
        {
            boost::asio::async_write(
                *mSocketPtr,
                boost::asio::buffer(buffer, bufferLen),
                boost::bind(
                    &AsioSessionState::onWriteCompletion,
                    shared_from_this(),
                    boost::asio::placeholders::error,
                    boost::asio::placeholders::bytes_transferred));
        }

        void implWrite(AsioSessionState &toBeNotified, const char * buffer, std::size_t bufferLen)
        {
            boost::asio::async_write(
                *mSocketPtr,
                boost::asio::buffer(buffer, bufferLen),
                boost::bind(
                    &AsioSessionState::onWriteCompletion,
                    toBeNotified.shared_from_this(),
                    boost::asio::placeholders::error,
                    boost::asio::placeholders::bytes_transferred));
        }

        void implAccept()
        {
            TcpAsioAcceptor & tcpAsioAcceptor = 
                static_cast<TcpAsioAcceptor &>(*mTransport.getAcceptorPtr());

            tcpAsioAcceptor.mAcceptor.async_accept(
                *mSocketPtr,
                boost::bind(
                    &AsioSessionState::onAccept,
                    shared_from_this(),
                    boost::asio::placeholders::error));
        }

        bool implOnAccept()
        {
            boost::asio::ip::tcp::endpoint endpoint = 
                mSocketPtr->remote_endpoint();

            sockaddr_in addr;
            memset(&addr, 0, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_port = htons(endpoint.port());
            addr.sin_addr.s_addr = htonl(endpoint.address().to_v4().to_ulong());
            mIpAddress = IpAddress(addr);

            TcpAsioServerTransport & transport = 
                static_cast<TcpAsioServerTransport &>(mTransport);

            return transport.isClientAddrAllowed(addr);
        }

        int implGetNative() const
        {
            return mSocketPtr->native();
        }

        boost::function0<void> implGetCloseFunctor()
        {
            return boost::bind(
                &TcpAsioSessionState::closeSocket,
                mSocketPtr);
        }

        void implClose()
        {
            mSocketPtr->close();
        }

        ClientTransportAutoPtr implCreateClientTransport()
        {
            int fd = implGetNative();

            std::auto_ptr<TcpClientTransport> tcpClientTransport(
                new TcpClientTransport(fd));

            boost::asio::ip::tcp::endpoint endpoint = 
                mSocketPtr->remote_endpoint();

            sockaddr_in addr;
            memset(&addr, 0, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_port = htons(endpoint.port());
            addr.sin_addr.s_addr = htonl(endpoint.address().to_v4().to_ulong());
            tcpClientTransport->setRemoteAddr(addr);

            return ClientTransportAutoPtr(tcpClientTransport.release());
        }

        void implTransferNativeFrom(I_ClientTransport & clientTransport)
        {
            TcpClientTransport *pTcpClientTransport =
                dynamic_cast<TcpClientTransport *>(&clientTransport);

            if (pTcpClientTransport == NULL)
            {
                RCF_THROW(
                    Exception("incompatible client transport"))
                    (typeid(clientTransport));
            }

            TcpClientTransport & tcpClientTransport = *pTcpClientTransport;

            // TODO: exception safety
            mSocketPtr->assign(
                boost::asio::ip::tcp::v4(),
                tcpClientTransport.releaseFd());
        }

        static void closeSocket(TcpAsioSocketPtr socketPtr)
        {
            socketPtr->close();
        }

    private:
        TcpAsioSocketPtr            mSocketPtr;
        IpAddress                   mIpAddress;
    };

    // TcpAsioServerTransport

    TcpAsioServerTransport::TcpAsioServerTransport(int port) :
        mPort(port)
    {}

    TcpAsioServerTransport::TcpAsioServerTransport(
        const std::string &networkInterface, 
        int port) :
            mPort(port)
    {
        setNetworkInterface(networkInterface);
    }

    ServerTransportPtr TcpAsioServerTransport::clone()
    {
        return ServerTransportPtr(new TcpAsioServerTransport(mPort));
    }

    AsioSessionStatePtr TcpAsioServerTransport::implCreateSessionState()
    {
        return AsioSessionStatePtr( new TcpAsioSessionState(*this, mDemuxerPtr) );
    }

    int TcpAsioServerTransport::getPort() const
    {
        return mPort;
    }

    void TcpAsioServerTransport::implOpen()
    {
        RCF_ASSERT(!mAcceptorPtr);

        if (mPort >= 0)
        {
            boost::shared_ptr<TcpAsioAcceptor> acceptorPtr(
                new TcpAsioAcceptor(*mDemuxerPtr));

            mAcceptorPtr = acceptorPtr;
            int portOut = 0;
            acceptorPtr->open(getNetworkInterface(), mPort, portOut);
            mPort = portOut;
        }
    }

    ClientTransportAutoPtr TcpAsioServerTransport::implCreateClientTransport(
        const I_Endpoint &endpoint)
    {
        const TcpEndpoint &tcpEndpoint = 
            dynamic_cast<const TcpEndpoint &>(endpoint);

        ClientTransportAutoPtr clientTransportAutoPtr(
            new TcpClientTransport(tcpEndpoint.getIp(), tcpEndpoint.getPort()));

        return clientTransportAutoPtr;
    }

} // namespace RCF
